---
title: "Untitled"
output: html_document
date: "2024-03-22"
---


```{r}
library(Rcpp)
sourceCpp("Hungarian.cpp")
```

```{r}
matrix_to_list <- function(matrix) {
  # Split the matrix into a list of integer vectors by row
  list_matrix <- split(matrix, row(matrix))

  # Convert each element of the list to an integer vector
  list_matrix <- lapply(list_matrix, as.integer)

  return(list_matrix)
}
```



#génération de tous les clusters prédits et de toutes classes correspondant aux données : 
```{r cleaning, include=FALSE}

generer_tableau <- function(n, k) {
  tableau <- matrix(sample(1:k, n * 2, replace = TRUE), ncol = 2)
  return(tableau)
}

generer_matrice <- function(n, k){
  matrice <- replicate(n, sample(1:k, n, replace = TRUE), simplify = FALSE)
  return(matrice)
}

n <- 400 
k <- 10   

resultat <- generer_tableau(n, k)

cost_matrix <- matrix(0, nrow = k, ncol = k)
```

#calcul de la matrice de coût par une fonction de comptage simple d'occurence cluster/classe :
```{r cleaning, include=FALSE}
for (i in 1:n) {
  cluster <- resultat[i, 1]  
  classe <- resultat[i, 2]   
  cost_matrix[cluster, classe] <- cost_matrix[cluster, classe] + 1
}

# Normaliser la matrice de coût
cost_matrix <- 1 - cost_matrix / n
```


#calcul de la matrice de coût par une distance euclidienne de la différence entre centroïde et moyenne de la classe : 
```{r cleaning, include=FALSE}

data <- read.csv("données_centroides_classe-cluster_MNIST.csv")
subdata<-data[, -(1:2)]

cost_matrix <- matrix(0, nrow = 10, ncol = 10)

for (i in 1: 10) {
  for (j in 11: 20) {
    cost_matrix[i,j-10]=sum((subdata[i,] - subdata[j,])^2)
  }
}

```

#génération aléatoire des centroïdes des classes et clusters:

```{r cleaning, include=FALSE}

matrice_gaussienne <- matrix(rnorm(nb_lignes * nb_colonnes), nrow = nb_lignes, ncol = nb_colonnes)

matrice_gaussienne_normalisee <- pnorm(matrice_gaussienne)

```

```{r cleaning, include=FALSE}
# Afficher la matrice de coût
hungarian_cost_matrix = matrix_to_list(cost_matrix)
print(hungarian_cost_matrix)

optimal_cost <- Hungarian(hungarian_cost_matrix)
print(optimal_cost)
```

# Compute Complexity

```{r}
times <- list()  # Initialize times as an empty list
n_times <- 0

for (n in seq(from = 10, to = 1000, by = 100)) {
  cost_matrix <- generer_matrice(n, k)
  timing <- system.time(total_cost <- Hungarian(cost_matrix))
  n_times <- n_times + 1
  times[[n_times]] <- timing["elapsed"]  # Append elapsed time to times list
}
```


